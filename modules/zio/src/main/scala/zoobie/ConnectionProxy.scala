package zoobie

import java.sql.Connection
import java.sql.Savepoint
import java.util
import java.util.Properties
import java.util.concurrent.Executor

@SuppressWarnings(Array("org.wartremover.warts.Var"))
class ConnectionProxy(connection: Connection) extends Connection {

  private var closed: Boolean = false

  private var autoCommit: Option[Boolean] = None
  private var readOnly: Option[Boolean] = None
  private var transactionIsolation: Option[Int] = None
  private var catalog: Option[String] = None
  private var schema: Option[String] = None

  override def close(): Unit = {
    if (closed) {
      ()
    } else {
      resetConnectionState()
      connection.clearWarnings()

      closed = true
    }
  }

  private def resetConnectionState(): Unit = {
    autoCommit.foreach(connection.setAutoCommit)
    readOnly.foreach(connection.setReadOnly)
    transactionIsolation.foreach(connection.setTransactionIsolation)
    catalog.foreach(connection.setCatalog)
    schema.foreach(connection.setSchema)
  }

  override def isClosed = closed

  override def createStatement() = {
    connection.createStatement()
  }

  override def createStatement(resultSetType: Int, concurrency: Int) = {
    connection.createStatement(resultSetType, concurrency)
  }

  override def createStatement(resultSetType: Int, concurrency: Int, holdability: Int) = {
    connection.createStatement(resultSetType, concurrency, holdability)
  }

  override def prepareCall(sql: String) = {
    connection.prepareCall(sql)
  }

  override def prepareCall(sql: String, resultSetType: Int, concurrency: Int) = {
    connection.prepareCall(sql, resultSetType, concurrency)
  }

  override def prepareCall(sql: String, resultSetType: Int, concurrency: Int, holdability: Int) = {
    connection.prepareCall(sql, resultSetType, concurrency, holdability)
  }

  override def prepareStatement(sql: String) = {
    connection.prepareStatement(sql)
  }

  override def prepareStatement(sql: String, autoGeneratedKeys: Int) = {
    connection.prepareStatement(sql)
  }

  override def prepareStatement(sql: String, resultSetType: Int, concurrency: Int) = {
    connection.prepareStatement(sql, resultSetType, concurrency)
  }

  override def prepareStatement(sql: String, resultSetType: Int, concurrency: Int, holdability: Int) = {
    connection.prepareStatement(sql, resultSetType, concurrency, holdability)
  }

  override def prepareStatement(sql: String, columnIndexes: Array[Int]) = {
    connection.prepareStatement(sql, columnIndexes)
  }

  override def prepareStatement(sql: String, columnNames: Array[String]) = {
    connection.prepareStatement(sql, columnNames)
  }

  override def getMetaData = connection.getMetaData

  override def commit() = connection.commit()
  override def rollback() = connection.rollback()
  override def rollback(savepoint: Savepoint) = connection.rollback(savepoint)

  override def getAutoCommit = connection.getAutoCommit
  override def setAutoCommit(autoCommit: Boolean): Unit = {
    if (this.autoCommit == None) {
      this.autoCommit = Some(connection.getAutoCommit)
    }
    connection.setAutoCommit(autoCommit)
  }

  override def isReadOnly = connection.isReadOnly
  override def setReadOnly(readOnly: Boolean): Unit = {
    if (this.readOnly == None) {
      this.readOnly = Some(connection.isReadOnly)
    }
    connection.setReadOnly(readOnly)
  }

  override def getTransactionIsolation = connection.getTransactionIsolation
  override def setTransactionIsolation(level: Int): Unit = {
    if (this.transactionIsolation == None) {
      this.transactionIsolation = Some(connection.getTransactionIsolation)
    }
    connection.setTransactionIsolation(level)
  }

  override def getCatalog = connection.getCatalog
  override def setCatalog(catalog: String): Unit = {
    if (this.catalog == None) {
      this.catalog = Some(connection.getCatalog)
    }
    connection.setCatalog(catalog)
  }

  override def getSchema = connection.getSchema
  override def setSchema(schema: String): Unit = {
    if (this.schema == None) {
      this.schema = Some(connection.getSchema)
    }
    connection.setSchema(schema)
  }

  override def getNetworkTimeout = connection.getNetworkTimeout
  @SuppressWarnings(Array("org.wartremover.warts.Throw"))
  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = {
    throw new IllegalAccessException("setNetworkTimeout not supported")
  }

  override def isWrapperFor(iface: Class[?]) = connection.isWrapperFor(iface)
  override def unwrap[T](iface: Class[T]) = connection.unwrap(iface)

  override def nativeSQL(sql: String) = connection.nativeSQL(sql)

  override def getWarnings = connection.getWarnings
  override def clearWarnings() = connection.clearWarnings()

  override def getTypeMap = connection.getTypeMap
  override def setTypeMap(map: util.Map[String, Class[?]]) = connection.setTypeMap(map)

  override def getHoldability = connection.getHoldability
  override def setHoldability(holdability: Int) = connection.setHoldability(holdability)

  override def setSavepoint() = connection.setSavepoint()
  override def setSavepoint(name: String) = connection.setSavepoint(name)
  override def releaseSavepoint(savepoint: Savepoint) = connection.releaseSavepoint(savepoint)

  override def createClob() = connection.createClob()
  override def createBlob() = connection.createBlob()
  override def createNClob() = connection.createNClob()
  override def createSQLXML() = connection.createSQLXML()

  override def isValid(timeout: Int): Boolean = connection.isValid(timeout)

  override def setClientInfo(name: String, value: String) = connection.setClientInfo(name, value)
  override def setClientInfo(properties: Properties) = connection.setClientInfo(properties)
  override def getClientInfo = connection.getClientInfo
  override def getClientInfo(name: String) = connection.getClientInfo(name)

  override def createArrayOf(typeName: String, elements: Array[AnyRef]) = connection.createArrayOf(typeName, elements)
  override def createStruct(typeName: String, attributes: Array[AnyRef]) = connection.createStruct(typeName, attributes)

  override def abort(executor: Executor): Unit = connection.abort(executor)
}
